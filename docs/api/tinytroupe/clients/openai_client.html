<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tinytroupe.clients.openai_client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tinytroupe.clients.openai_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import configparser
import logging
import os
import pickle
import threading
import time
from contextlib import contextmanager
from typing import Union

import httpx
import openai
import tiktoken
from openai import APITimeoutError, AzureOpenAI, OpenAI

from tinytroupe import config_manager, utils
from tinytroupe.control import transactional

logger = logging.getLogger(&#34;tinytroupe&#34;)

# We&#39;ll use various configuration elements below
config = utils.read_config_file()

###########################################################################
# Client class
###########################################################################


class OpenAIClient:
    &#34;&#34;&#34;
    A utility class for interacting with the OpenAI API.
    &#34;&#34;&#34;

    @config_manager.config_defaults(
        cache_api_calls=&#34;cache_api_calls&#34;,
        cache_file_name=&#34;cache_file_name&#34;,
        max_concurrent_model_calls=&#34;max_concurrent_model_calls&#34;,
    )
    def __init__(
        self,
        cache_api_calls=None,
        cache_file_name=None,
        max_concurrent_model_calls=None,
    ) -&gt; None:
        logger.debug(&#34;Initializing OpenAIClient&#34;)
        self._cache_lock = threading.RLock()
        self._max_concurrent_model_calls = self._normalize_concurrency_limit(
            max_concurrent_model_calls
        )
        self._concurrency_semaphore = (
            threading.BoundedSemaphore(self._max_concurrent_model_calls)
            if self._max_concurrent_model_calls is not None
            else None
        )

        # Initialize cost tracking variables
        self._cost_stats_lock = threading.RLock()
        self._reset_cost_stats()

        self.set_api_cache(cache_api_calls, cache_file_name)

    @staticmethod
    def _normalize_concurrency_limit(value):
        if value is None:
            return None

        try:
            candidate = int(value)
        except (TypeError, ValueError):
            logger.warning(
                &#34;Invalid concurrency limit &#39;%s&#39;. Concurrency protection disabled.&#34;,
                value,
            )
            return None

        if candidate &lt;= 0:
            return None

        return candidate

    @config_manager.config_defaults(cache_file_name=&#34;cache_file_name&#34;)
    def set_api_cache(self, cache_api_calls, cache_file_name=None):
        &#34;&#34;&#34;
        Enables or disables the caching of API calls.

        Args:
        cache_file_name (str): The name of the file to use for caching API calls.
        &#34;&#34;&#34;
        self.cache_api_calls = cache_api_calls
        self.cache_file_name = cache_file_name
        if self.cache_api_calls:
            # load the cache, if any
            self.api_cache = self._load_cache()

    def _reset_cost_stats(self):
        &#34;&#34;&#34;
        Resets the cost statistics to zero.
        &#34;&#34;&#34;
        with self._cost_stats_lock:
            self._input_tokens = 0
            self._output_tokens = 0
            self._total_tokens = 0
            self._model_calls = 0
            self._cached_calls = 0

    @config_manager.config_defaults(timeout=&#34;timeout&#34;)
    def _setup_from_config(self, timeout=None):
        &#34;&#34;&#34;
        Sets up the OpenAI API configurations for this client.
        &#34;&#34;&#34;

        # On Sept./Oct. 2025 I noticed that the OpenAI library was randomly hanging during requests,
        # and even the timeout was not being enforced. So after nearly going mad, I found out the
        # strategy below to cancel problematic requests.

        # Create httpx client with proper timeouts to prevent hanging
        # This ensures timeouts work at ALL levels: connection, read, write, pool
        httpx_client = httpx.Client(
            timeout=httpx.Timeout(
                timeout=timeout,  # Overall timeout
                connect=10.0,  # Connection timeout (fixed at 10s)
                read=timeout,  # Read timeout (from config)
                write=10.0,  # Write timeout (fixed at 10s)
                pool=5.0,  # Pool timeout (fixed at 5s)
            )
        )

        # we set max_retries to 0 because we do our own retrying with customized exponential backoff
        self.client = OpenAI(
            api_key=os.getenv(&#34;OPENAI_API_KEY&#34;), max_retries=0, http_client=httpx_client
        )

    @config_manager.config_defaults(
        model=&#34;model&#34;,
        temperature=&#34;temperature&#34;,
        max_completion_tokens=&#34;max_completion_tokens&#34;,
        frequency_penalty=&#34;frequency_penalty&#34;,
        presence_penalty=&#34;presence_penalty&#34;,
        timeout=&#34;timeout&#34;,
        max_attempts=&#34;max_attempts&#34;,
        waiting_time=&#34;waiting_time&#34;,
        exponential_backoff_factor=&#34;exponential_backoff_factor&#34;,
        response_format=None,
        echo=None,
    )
    def send_message(
        self,
        current_messages,
        dedent_messages=True,
        model=None,
        temperature=None,
        max_completion_tokens=None,
        top_p=None,
        frequency_penalty=None,
        presence_penalty=None,
        stop=None,
        timeout=None,
        max_attempts=None,
        waiting_time=None,
        exponential_backoff_factor=None,
        n=1,
        response_format=None,
        enable_pydantic_model_return=False,
        echo=False,
    ):
        &#34;&#34;&#34;
        Sends a message to the OpenAI API and returns the response.

        Args:
        current_messages (list): A list of dictionaries representing the conversation history.
        dedent_messages (bool): Whether to dedent the messages before sending them to the API.
        model (str): The ID of the model to use for generating the response.
        temperature (float): Controls the &#34;creativity&#34; of the response. Higher values result in more diverse responses.
        max_completion_tokens (int): The maximum number of tokens (words or punctuation marks) to generate in the response.
        top_p (float): Controls the &#34;quality&#34; of the response. Higher values result in more coherent responses.
        frequency_penalty (float): Controls the &#34;repetition&#34; of the response. Higher values result in less repetition.
        presence_penalty (float): Controls the &#34;diversity&#34; of the response. Higher values result in more diverse responses.
        stop (str): A string that, if encountered in the generated response, will cause the generation to stop.
        max_attempts (int): The maximum number of attempts to make before giving up on generating a response.
        timeout (int): The maximum number of seconds to wait for a response from the API.
        waiting_time (int): The number of seconds to wait between requests.
        exponential_backoff_factor (int): The factor by which to increase the waiting time between requests.
        n (int): The number of completions to generate.
        response_format: The format of the response, if any.
        echo (bool): Whether to echo the input message in the response.
        enable_pydantic_model_return (bool): Whether to enable Pydantic model return instead of dict when possible.

        Returns:
        A dictionary representing the generated response.
        &#34;&#34;&#34;

        from tinytroupe.clients import (  # avoid circular import
            InvalidRequestError,
            NonTerminalError,
        )

        def aux_exponential_backoff():
            nonlocal waiting_time

            # in case waiting time was initially set to 0
            if waiting_time &lt;= 0:
                waiting_time = 2

            logger.info(
                f&#34;Request failed. Waiting {waiting_time} seconds between requests...&#34;
            )
            time.sleep(waiting_time)

            # exponential backoff
            waiting_time = waiting_time * exponential_backoff_factor

        # setup the OpenAI configurations for this client.
        self._setup_from_config()

        # dedent the messages (field &#39;content&#39; only) if needed (using textwrap)
        if dedent_messages:
            for message in current_messages:
                if &#34;content&#34; in message:
                    message[&#34;content&#34;] = utils.dedent(message[&#34;content&#34;])

        # We need to adapt the parameters to the API type, so we create a dictionary with them first
        chat_api_params = {
            &#34;model&#34;: model,
            &#34;messages&#34;: current_messages,
            &#34;temperature&#34;: temperature,
            &#34;max_completion_tokens&#34;: max_completion_tokens,
            &#34;top_p&#34;: top_p,
            &#34;frequency_penalty&#34;: frequency_penalty,
            &#34;presence_penalty&#34;: presence_penalty,
            &#34;stop&#34;: stop,
            &#34;timeout&#34;: timeout,
            &#34;stream&#34;: False,
            &#34;n&#34;: n,
        }

        if response_format is not None:
            chat_api_params[&#34;response_format&#34;] = response_format

        # remove any parameter that is None, so we use the API defaults
        chat_api_params = {k: v for k, v in chat_api_params.items() if v is not None}

        i = 0
        while i &lt; max_attempts:
            try:
                i += 1

                try:
                    logger.debug(
                        f&#34;Sending messages to OpenAI API. Token count={self._count_tokens(current_messages, model)}.&#34;
                    )
                except NotImplementedError:
                    logger.debug(f&#34;Token count not implemented for model {model}.&#34;)

                start_time = time.monotonic()
                logger.debug(
                    f&#34;Calling model with client class {self.__class__.__name__}.&#34;
                )

                ###############################################################
                # call the model, either from the cache or from the API
                ###############################################################
                cache_key = str((model, chat_api_params))  # need string to be hashable

                pre_cached_response = self._get_cached_response(cache_key)

                should_wait_before_call = (
                    waiting_time &gt; 0 and pre_cached_response is None
                )

                if should_wait_before_call:
                    logger.info(
                        f&#34;Waiting {waiting_time} seconds before next API request (to avoid throttling)...&#34;
                    )
                    time.sleep(waiting_time)

                with self._concurrency_slot():
                    response = None
                    cached_response = (
                        pre_cached_response
                        if pre_cached_response is not None
                        else self._get_cached_response(cache_key)
                    )

                    if cached_response is not None:
                        response = cached_response
                    else:
                        response = self._raw_model_call(model, chat_api_params)
                        if self.cache_api_calls:
                            with self._cache_lock:
                                existing = (
                                    self.api_cache.get(cache_key)
                                    if hasattr(self, &#34;api_cache&#34;)
                                    else None
                                )
                                if existing is None:
                                    self.api_cache[cache_key] = response
                                    self._save_cache()
                                else:
                                    response = existing

                    raw_message = self._raw_model_response_extractor(response)

                    # Update cost statistics
                    self._update_cost_stats(response, cached_response is not None)

                logger.debug(f&#34;Got response from API: {response}&#34;)
                end_time = time.monotonic()
                logger.debug(
                    f&#34;Got response in {end_time - start_time:.2f} seconds after {i} attempts.&#34;
                )

                if enable_pydantic_model_return:
                    return utils.to_pydantic_or_sanitized_dict(
                        raw_message,
                        model=response_format,
                    )
                else:
                    return utils.sanitize_dict(raw_message)

            except InvalidRequestError as e:
                logger.error(f&#34;[{i}] Invalid request error, won&#39;t retry: {e}&#34;)

                # there&#39;s no point in retrying if the request is invalid
                # so we return None right away
                return None

            except openai.BadRequestError as e:
                logger.error(f&#34;[{i}] Invalid request error, won&#39;t retry: {e}&#34;)

                # there&#39;s no point in retrying if the request is invalid
                # so we return None right away
                return None

            except openai.RateLimitError:
                logger.warning(
                    f&#34;[{i}] Rate limit error, waiting a bit and trying again.&#34;
                )
                aux_exponential_backoff()

            except NonTerminalError as e:
                logger.error(f&#34;[{i}] Non-terminal error: {e}&#34;)
                aux_exponential_backoff()

            except APITimeoutError as e:
                logger.error(f&#34;[{i}] API Timeout error: {e}&#34;)
                # no exponential timeout backoff here, just retry

            except Exception as e:
                logger.error(f&#34;[{i}] {type(e).__name__} Error: {e}&#34;)
                aux_exponential_backoff()

        logger.error(f&#34;Failed to get response after {max_attempts} attempts.&#34;)
        return None

    def _raw_model_call(self, model, chat_api_params):
        &#34;&#34;&#34;
        Calls the OpenAI API with the given parameters. Subclasses should
        override this method to implement their own API calls.
        &#34;&#34;&#34;
        # adjust parameters depending on the model
        if self._is_reasoning_model(model):
            # Reasoning models have slightly different parameters
            del chat_api_params[&#34;stream&#34;]
            del chat_api_params[&#34;temperature&#34;]
            del chat_api_params[&#34;top_p&#34;]
            del chat_api_params[&#34;frequency_penalty&#34;]
            del chat_api_params[&#34;presence_penalty&#34;]

            chat_api_params[&#34;max_completion_tokens&#34;] = chat_api_params[
                &#34;max_completion_tokens&#34;
            ]
            del chat_api_params[&#34;max_completion_tokens&#34;]

            chat_api_params[&#34;reasoning_effort&#34;] = config_manager.get(&#34;reasoning_effort&#34;)

        # gpt-5 only supports temperature=1.0 (default), so remove temperature param if not default
        if &#34;gpt-5&#34; in model and &#34;temperature&#34; in chat_api_params:
            if chat_api_params[&#34;temperature&#34;] != 1.0:
                logger.warning(
                    f&#34;gpt-5 only supports temperature=1.0, removing custom temperature={chat_api_params[&#39;temperature&#39;]}&#34;
                )
                del chat_api_params[&#34;temperature&#34;]

        # To make the log cleaner, we remove the messages from the logged parameters
        logged_params = {k: v for k, v in chat_api_params.items() if k != &#34;messages&#34;}

        if &#34;response_format&#34; in chat_api_params:
            # to enforce the response format via pydantic, we need to use a different method

            if &#34;stream&#34; in chat_api_params:
                del chat_api_params[&#34;stream&#34;]

            logger.debug(
                f&#34;Calling LLM model (using .parse too) with these parameters: {logged_params}. Not showing &#39;messages&#39; parameter.&#34;
            )
            # complete message
            logger.debug(
                f&#34;   --&gt; Complete messages sent to LLM: {chat_api_params[&#39;messages&#39;]}&#34;
            )

            result_message = self.client.beta.chat.completions.parse(**chat_api_params)

            return result_message

        else:
            logger.debug(
                f&#34;Calling LLM model with these parameters: {logged_params}. Not showing &#39;messages&#39; parameter.&#34;
            )
            return self.client.chat.completions.create(**chat_api_params)

    def _is_reasoning_model(self, model):
        return &#34;o1&#34; in model or &#34;o3&#34; in model

    def _raw_model_response_extractor(self, response):
        &#34;&#34;&#34;
        Extracts the response from the API response. Subclasses should
        override this method to implement their own response extraction.
        &#34;&#34;&#34;
        return response.choices[0].message.to_dict()

    def _get_cached_response(self, cache_key):
        if not self.cache_api_calls:
            return None

        cache_store = getattr(self, &#34;api_cache&#34;, None)
        if cache_store is None:
            return None

        with self._cache_lock:
            return cache_store.get(cache_key)

    @contextmanager
    def _concurrency_slot(self):
        if self._concurrency_semaphore is None:
            yield
            return

        self._concurrency_semaphore.acquire()
        try:
            yield
        finally:
            self._concurrency_semaphore.release()

    def _count_tokens(self, messages: list, model: str):
        &#34;&#34;&#34;
        Count the number of OpenAI tokens in a list of messages using tiktoken.

        Adapted from https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb

        Args:
        messages (list): A list of dictionaries representing the conversation history.
        model (str): The name of the model to use for encoding the string.
        &#34;&#34;&#34;
        try:
            try:
                encoding = tiktoken.encoding_for_model(model)
            except KeyError:
                logger.debug(
                    &#34;Token count: model not found. Using cl100k_base encoding.&#34;
                )
                encoding = tiktoken.get_encoding(&#34;cl100k_base&#34;)

            if (
                model
                in {
                    &#34;gpt-3.5-turbo-0613&#34;,
                    &#34;gpt-3.5-turbo-16k-0613&#34;,
                    &#34;gpt-4-0314&#34;,
                    &#34;gpt-4-32k-0314&#34;,
                    &#34;gpt-4-0613&#34;,
                    &#34;gpt-4-32k-0613&#34;,
                }
                or &#34;o1&#34; in model
                or &#34;o3&#34; in model
            ):  # assuming o1/3 models work the same way
                tokens_per_message = 3
                tokens_per_name = 1
            elif model == &#34;gpt-3.5-turbo-0301&#34;:
                tokens_per_message = (
                    4  # every message follows &lt;|start|&gt;{role/name}\n{content}&lt;|end|&gt;\n
                )
                tokens_per_name = -1  # if there&#39;s a name, the role is omitted
            elif &#34;gpt-3.5-turbo&#34; in model:
                logger.debug(
                    &#34;Token count: gpt-3.5-turbo may update over time. Returning num tokens assuming gpt-3.5-turbo-0613.&#34;
                )
                return self._count_tokens(messages, model=&#34;gpt-3.5-turbo-0613&#34;)
            elif (&#34;gpt-4&#34; in model) or (&#34;ppo&#34; in model):
                logger.debug(
                    &#34;Token count: gpt-4 may update over time. Returning num tokens assuming gpt-4-0613.&#34;
                )
                return self._count_tokens(messages, model=&#34;gpt-4-0613&#34;)
            elif &#34;gpt-5&#34; in model:
                logger.debug(
                    &#34;Token count: no info on GPT-5 tokenizer yet, so we are just reusing GPT-4&#39;s.&#34;
                )
                return self._count_tokens(messages, model=&#34;gpt-4-0613&#34;)
            else:
                raise NotImplementedError(
                    f&#34;&#34;&#34;_count_tokens() is not implemented for model {model}. See https://github.com/openai/openai-python/blob/main/chatml.md for information on how messages are converted to tokens.&#34;&#34;&#34;
                )

            num_tokens = 0
            for message in messages:
                num_tokens += tokens_per_message
                for key, value in message.items():
                    num_tokens += len(encoding.encode(value))
                    if key == &#34;name&#34;:
                        num_tokens += tokens_per_name
            num_tokens += 3  # every reply is primed with &lt;|start|&gt;assistant&lt;|message|&gt;
            return num_tokens

        except Exception as e:
            logger.error(f&#34;Error counting tokens: {e}&#34;)
            return None

    def _save_cache(self):
        &#34;&#34;&#34;
        Saves the API cache to disk. We use pickle to do that because some obj
        are not JSON serializable.
        &#34;&#34;&#34;
        # use pickle to save the cache
        with open(self.cache_file_name, &#34;wb&#34;) as f:
            pickle.dump(self.api_cache, f)

    def _load_cache(self):
        &#34;&#34;&#34;
        Loads the API cache from disk.
        &#34;&#34;&#34;
        if os.path.exists(self.cache_file_name):
            try:
                with open(self.cache_file_name, &#34;rb&#34;) as f:
                    return pickle.load(f)
            except (EOFError, pickle.UnpicklingError) as e:
                logger.warning(f&#34;Cache file exists but could not be loaded: {e}. Starting with empty cache.&#34;)
                return {}
        return {}

    @config_manager.config_defaults(model=&#34;embedding_model&#34;)
    def get_embedding(self, text, model=None):
        &#34;&#34;&#34;
        Gets the embedding of the given text using the specified model.

        Args:
        text (str): The text to embed.
        model (str): The name of the model to use for embedding the text.

        Returns:
        The embedding of the text.
        &#34;&#34;&#34;
        response = self._raw_embedding_model_call(text, model)
        return self._raw_embedding_model_response_extractor(response)

    def _raw_embedding_model_call(self, text, model):
        &#34;&#34;&#34;
        Calls the OpenAI API to get the embedding of the given text. Subclasses should
        override this method to implement their own API calls.
        &#34;&#34;&#34;
        return self.client.embeddings.create(input=[text], model=model)

    def _raw_embedding_model_response_extractor(self, response):
        &#34;&#34;&#34;
        Extracts the embedding from the API response. Subclasses should
        override this method to implement their own response extraction.
        &#34;&#34;&#34;
        return response.data[0].embedding

    def _update_cost_stats(self, response, was_cached):
        &#34;&#34;&#34;
        Updates the cost statistics based on the API response.

        Args:
            response: The response object from the API.
            was_cached (bool): Whether this response came from cache.
        &#34;&#34;&#34;
        with self._cost_stats_lock:
            if was_cached:
                self._cached_calls += 1
            else:
                self._model_calls += 1

            # Extract token usage from response if available
            if hasattr(response, &#34;usage&#34;):
                usage = response.usage
                if hasattr(usage, &#34;prompt_tokens&#34;):
                    self._input_tokens += usage.prompt_tokens
                if hasattr(usage, &#34;completion_tokens&#34;):
                    self._output_tokens += usage.completion_tokens
                if hasattr(usage, &#34;total_tokens&#34;):
                    self._total_tokens += usage.total_tokens

                # Log the latest values in debug mode
                logger.debug(
                    f&#34;Cost stats updated - Input tokens: {usage.prompt_tokens if hasattr(usage, &#39;prompt_tokens&#39;) else 0}, &#34;
                    f&#34;Output tokens: {usage.completion_tokens if hasattr(usage, &#39;completion_tokens&#39;) else 0}, &#34;
                    f&#34;Total tokens: {usage.total_tokens if hasattr(usage, &#39;total_tokens&#39;) else 0}, &#34;
                    f&#34;Cached: {was_cached}&#34;
                )

    def get_cost_stats(self):
        &#34;&#34;&#34;
        Returns the current cost statistics.

        Returns:
            dict: A dictionary containing cost statistics with keys:
                - input_tokens: Number of input/prompt tokens used
                - output_tokens: Number of output/completion tokens used
                - total_tokens: Total number of tokens used
                - model_calls: Number of actual API calls made
                - cached_calls: Number of calls served from cache
        &#34;&#34;&#34;
        with self._cost_stats_lock:
            return {
                &#34;input_tokens&#34;: self._input_tokens,
                &#34;output_tokens&#34;: self._output_tokens,
                &#34;total_tokens&#34;: self._total_tokens,
                &#34;model_calls&#34;: self._model_calls,
                &#34;cached_calls&#34;: self._cached_calls,
            }

    def pretty_print_cost_stats(self):
        &#34;&#34;&#34;
        Pretty prints the cost statistics to the console.
        &#34;&#34;&#34;
        stats = self.get_cost_stats()
        print(&#34;\n&#34; + &#34;=&#34; * 60)
        print(&#34;LLM API COST STATISTICS&#34;)
        print(&#34;=&#34; * 60)
        print(f&#34;Input tokens:         {stats[&#39;input_tokens&#39;]:,}&#34;)
        print(f&#34;Output tokens:        {stats[&#39;output_tokens&#39;]:,}&#34;)
        print(f&#34;Total tokens:         {stats[&#39;total_tokens&#39;]:,}&#34;)
        print(f&#34;Model API calls:      {stats[&#39;model_calls&#39;]:,}&#34;)
        print(f&#34;Cached calls:         {stats[&#39;cached_calls&#39;]:,}&#34;)
        print(f&#34;Total calls:          {stats[&#39;model_calls&#39;] + stats[&#39;cached_calls&#39;]:,}&#34;)
        if stats[&#34;model_calls&#34;] &gt; 0:
            print(
                f&#34;Avg tokens per call:  {stats[&#39;total_tokens&#39;] / stats[&#39;model_calls&#39;]:.1f}&#34;
            )
        print(&#34;=&#34; * 60 + &#34;\n&#34;)

    def reset_cost_stats(self):
        &#34;&#34;&#34;
        Resets the cost statistics. This is the public method that users should call.
        &#34;&#34;&#34;
        self._reset_cost_stats()
        logger.info(&#34;Cost statistics have been reset.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tinytroupe.clients.openai_client.OpenAIClient"><code class="flex name class">
<span>class <span class="ident">OpenAIClient</span></span>
<span>(</span><span>cache_api_calls=None, cache_file_name=None, max_concurrent_model_calls=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A utility class for interacting with the OpenAI API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenAIClient:
    &#34;&#34;&#34;
    A utility class for interacting with the OpenAI API.
    &#34;&#34;&#34;

    @config_manager.config_defaults(
        cache_api_calls=&#34;cache_api_calls&#34;,
        cache_file_name=&#34;cache_file_name&#34;,
        max_concurrent_model_calls=&#34;max_concurrent_model_calls&#34;,
    )
    def __init__(
        self,
        cache_api_calls=None,
        cache_file_name=None,
        max_concurrent_model_calls=None,
    ) -&gt; None:
        logger.debug(&#34;Initializing OpenAIClient&#34;)
        self._cache_lock = threading.RLock()
        self._max_concurrent_model_calls = self._normalize_concurrency_limit(
            max_concurrent_model_calls
        )
        self._concurrency_semaphore = (
            threading.BoundedSemaphore(self._max_concurrent_model_calls)
            if self._max_concurrent_model_calls is not None
            else None
        )

        # Initialize cost tracking variables
        self._cost_stats_lock = threading.RLock()
        self._reset_cost_stats()

        self.set_api_cache(cache_api_calls, cache_file_name)

    @staticmethod
    def _normalize_concurrency_limit(value):
        if value is None:
            return None

        try:
            candidate = int(value)
        except (TypeError, ValueError):
            logger.warning(
                &#34;Invalid concurrency limit &#39;%s&#39;. Concurrency protection disabled.&#34;,
                value,
            )
            return None

        if candidate &lt;= 0:
            return None

        return candidate

    @config_manager.config_defaults(cache_file_name=&#34;cache_file_name&#34;)
    def set_api_cache(self, cache_api_calls, cache_file_name=None):
        &#34;&#34;&#34;
        Enables or disables the caching of API calls.

        Args:
        cache_file_name (str): The name of the file to use for caching API calls.
        &#34;&#34;&#34;
        self.cache_api_calls = cache_api_calls
        self.cache_file_name = cache_file_name
        if self.cache_api_calls:
            # load the cache, if any
            self.api_cache = self._load_cache()

    def _reset_cost_stats(self):
        &#34;&#34;&#34;
        Resets the cost statistics to zero.
        &#34;&#34;&#34;
        with self._cost_stats_lock:
            self._input_tokens = 0
            self._output_tokens = 0
            self._total_tokens = 0
            self._model_calls = 0
            self._cached_calls = 0

    @config_manager.config_defaults(timeout=&#34;timeout&#34;)
    def _setup_from_config(self, timeout=None):
        &#34;&#34;&#34;
        Sets up the OpenAI API configurations for this client.
        &#34;&#34;&#34;

        # On Sept./Oct. 2025 I noticed that the OpenAI library was randomly hanging during requests,
        # and even the timeout was not being enforced. So after nearly going mad, I found out the
        # strategy below to cancel problematic requests.

        # Create httpx client with proper timeouts to prevent hanging
        # This ensures timeouts work at ALL levels: connection, read, write, pool
        httpx_client = httpx.Client(
            timeout=httpx.Timeout(
                timeout=timeout,  # Overall timeout
                connect=10.0,  # Connection timeout (fixed at 10s)
                read=timeout,  # Read timeout (from config)
                write=10.0,  # Write timeout (fixed at 10s)
                pool=5.0,  # Pool timeout (fixed at 5s)
            )
        )

        # we set max_retries to 0 because we do our own retrying with customized exponential backoff
        self.client = OpenAI(
            api_key=os.getenv(&#34;OPENAI_API_KEY&#34;), max_retries=0, http_client=httpx_client
        )

    @config_manager.config_defaults(
        model=&#34;model&#34;,
        temperature=&#34;temperature&#34;,
        max_completion_tokens=&#34;max_completion_tokens&#34;,
        frequency_penalty=&#34;frequency_penalty&#34;,
        presence_penalty=&#34;presence_penalty&#34;,
        timeout=&#34;timeout&#34;,
        max_attempts=&#34;max_attempts&#34;,
        waiting_time=&#34;waiting_time&#34;,
        exponential_backoff_factor=&#34;exponential_backoff_factor&#34;,
        response_format=None,
        echo=None,
    )
    def send_message(
        self,
        current_messages,
        dedent_messages=True,
        model=None,
        temperature=None,
        max_completion_tokens=None,
        top_p=None,
        frequency_penalty=None,
        presence_penalty=None,
        stop=None,
        timeout=None,
        max_attempts=None,
        waiting_time=None,
        exponential_backoff_factor=None,
        n=1,
        response_format=None,
        enable_pydantic_model_return=False,
        echo=False,
    ):
        &#34;&#34;&#34;
        Sends a message to the OpenAI API and returns the response.

        Args:
        current_messages (list): A list of dictionaries representing the conversation history.
        dedent_messages (bool): Whether to dedent the messages before sending them to the API.
        model (str): The ID of the model to use for generating the response.
        temperature (float): Controls the &#34;creativity&#34; of the response. Higher values result in more diverse responses.
        max_completion_tokens (int): The maximum number of tokens (words or punctuation marks) to generate in the response.
        top_p (float): Controls the &#34;quality&#34; of the response. Higher values result in more coherent responses.
        frequency_penalty (float): Controls the &#34;repetition&#34; of the response. Higher values result in less repetition.
        presence_penalty (float): Controls the &#34;diversity&#34; of the response. Higher values result in more diverse responses.
        stop (str): A string that, if encountered in the generated response, will cause the generation to stop.
        max_attempts (int): The maximum number of attempts to make before giving up on generating a response.
        timeout (int): The maximum number of seconds to wait for a response from the API.
        waiting_time (int): The number of seconds to wait between requests.
        exponential_backoff_factor (int): The factor by which to increase the waiting time between requests.
        n (int): The number of completions to generate.
        response_format: The format of the response, if any.
        echo (bool): Whether to echo the input message in the response.
        enable_pydantic_model_return (bool): Whether to enable Pydantic model return instead of dict when possible.

        Returns:
        A dictionary representing the generated response.
        &#34;&#34;&#34;

        from tinytroupe.clients import (  # avoid circular import
            InvalidRequestError,
            NonTerminalError,
        )

        def aux_exponential_backoff():
            nonlocal waiting_time

            # in case waiting time was initially set to 0
            if waiting_time &lt;= 0:
                waiting_time = 2

            logger.info(
                f&#34;Request failed. Waiting {waiting_time} seconds between requests...&#34;
            )
            time.sleep(waiting_time)

            # exponential backoff
            waiting_time = waiting_time * exponential_backoff_factor

        # setup the OpenAI configurations for this client.
        self._setup_from_config()

        # dedent the messages (field &#39;content&#39; only) if needed (using textwrap)
        if dedent_messages:
            for message in current_messages:
                if &#34;content&#34; in message:
                    message[&#34;content&#34;] = utils.dedent(message[&#34;content&#34;])

        # We need to adapt the parameters to the API type, so we create a dictionary with them first
        chat_api_params = {
            &#34;model&#34;: model,
            &#34;messages&#34;: current_messages,
            &#34;temperature&#34;: temperature,
            &#34;max_completion_tokens&#34;: max_completion_tokens,
            &#34;top_p&#34;: top_p,
            &#34;frequency_penalty&#34;: frequency_penalty,
            &#34;presence_penalty&#34;: presence_penalty,
            &#34;stop&#34;: stop,
            &#34;timeout&#34;: timeout,
            &#34;stream&#34;: False,
            &#34;n&#34;: n,
        }

        if response_format is not None:
            chat_api_params[&#34;response_format&#34;] = response_format

        # remove any parameter that is None, so we use the API defaults
        chat_api_params = {k: v for k, v in chat_api_params.items() if v is not None}

        i = 0
        while i &lt; max_attempts:
            try:
                i += 1

                try:
                    logger.debug(
                        f&#34;Sending messages to OpenAI API. Token count={self._count_tokens(current_messages, model)}.&#34;
                    )
                except NotImplementedError:
                    logger.debug(f&#34;Token count not implemented for model {model}.&#34;)

                start_time = time.monotonic()
                logger.debug(
                    f&#34;Calling model with client class {self.__class__.__name__}.&#34;
                )

                ###############################################################
                # call the model, either from the cache or from the API
                ###############################################################
                cache_key = str((model, chat_api_params))  # need string to be hashable

                pre_cached_response = self._get_cached_response(cache_key)

                should_wait_before_call = (
                    waiting_time &gt; 0 and pre_cached_response is None
                )

                if should_wait_before_call:
                    logger.info(
                        f&#34;Waiting {waiting_time} seconds before next API request (to avoid throttling)...&#34;
                    )
                    time.sleep(waiting_time)

                with self._concurrency_slot():
                    response = None
                    cached_response = (
                        pre_cached_response
                        if pre_cached_response is not None
                        else self._get_cached_response(cache_key)
                    )

                    if cached_response is not None:
                        response = cached_response
                    else:
                        response = self._raw_model_call(model, chat_api_params)
                        if self.cache_api_calls:
                            with self._cache_lock:
                                existing = (
                                    self.api_cache.get(cache_key)
                                    if hasattr(self, &#34;api_cache&#34;)
                                    else None
                                )
                                if existing is None:
                                    self.api_cache[cache_key] = response
                                    self._save_cache()
                                else:
                                    response = existing

                    raw_message = self._raw_model_response_extractor(response)

                    # Update cost statistics
                    self._update_cost_stats(response, cached_response is not None)

                logger.debug(f&#34;Got response from API: {response}&#34;)
                end_time = time.monotonic()
                logger.debug(
                    f&#34;Got response in {end_time - start_time:.2f} seconds after {i} attempts.&#34;
                )

                if enable_pydantic_model_return:
                    return utils.to_pydantic_or_sanitized_dict(
                        raw_message,
                        model=response_format,
                    )
                else:
                    return utils.sanitize_dict(raw_message)

            except InvalidRequestError as e:
                logger.error(f&#34;[{i}] Invalid request error, won&#39;t retry: {e}&#34;)

                # there&#39;s no point in retrying if the request is invalid
                # so we return None right away
                return None

            except openai.BadRequestError as e:
                logger.error(f&#34;[{i}] Invalid request error, won&#39;t retry: {e}&#34;)

                # there&#39;s no point in retrying if the request is invalid
                # so we return None right away
                return None

            except openai.RateLimitError:
                logger.warning(
                    f&#34;[{i}] Rate limit error, waiting a bit and trying again.&#34;
                )
                aux_exponential_backoff()

            except NonTerminalError as e:
                logger.error(f&#34;[{i}] Non-terminal error: {e}&#34;)
                aux_exponential_backoff()

            except APITimeoutError as e:
                logger.error(f&#34;[{i}] API Timeout error: {e}&#34;)
                # no exponential timeout backoff here, just retry

            except Exception as e:
                logger.error(f&#34;[{i}] {type(e).__name__} Error: {e}&#34;)
                aux_exponential_backoff()

        logger.error(f&#34;Failed to get response after {max_attempts} attempts.&#34;)
        return None

    def _raw_model_call(self, model, chat_api_params):
        &#34;&#34;&#34;
        Calls the OpenAI API with the given parameters. Subclasses should
        override this method to implement their own API calls.
        &#34;&#34;&#34;
        # adjust parameters depending on the model
        if self._is_reasoning_model(model):
            # Reasoning models have slightly different parameters
            del chat_api_params[&#34;stream&#34;]
            del chat_api_params[&#34;temperature&#34;]
            del chat_api_params[&#34;top_p&#34;]
            del chat_api_params[&#34;frequency_penalty&#34;]
            del chat_api_params[&#34;presence_penalty&#34;]

            chat_api_params[&#34;max_completion_tokens&#34;] = chat_api_params[
                &#34;max_completion_tokens&#34;
            ]
            del chat_api_params[&#34;max_completion_tokens&#34;]

            chat_api_params[&#34;reasoning_effort&#34;] = config_manager.get(&#34;reasoning_effort&#34;)

        # gpt-5 only supports temperature=1.0 (default), so remove temperature param if not default
        if &#34;gpt-5&#34; in model and &#34;temperature&#34; in chat_api_params:
            if chat_api_params[&#34;temperature&#34;] != 1.0:
                logger.warning(
                    f&#34;gpt-5 only supports temperature=1.0, removing custom temperature={chat_api_params[&#39;temperature&#39;]}&#34;
                )
                del chat_api_params[&#34;temperature&#34;]

        # To make the log cleaner, we remove the messages from the logged parameters
        logged_params = {k: v for k, v in chat_api_params.items() if k != &#34;messages&#34;}

        if &#34;response_format&#34; in chat_api_params:
            # to enforce the response format via pydantic, we need to use a different method

            if &#34;stream&#34; in chat_api_params:
                del chat_api_params[&#34;stream&#34;]

            logger.debug(
                f&#34;Calling LLM model (using .parse too) with these parameters: {logged_params}. Not showing &#39;messages&#39; parameter.&#34;
            )
            # complete message
            logger.debug(
                f&#34;   --&gt; Complete messages sent to LLM: {chat_api_params[&#39;messages&#39;]}&#34;
            )

            result_message = self.client.beta.chat.completions.parse(**chat_api_params)

            return result_message

        else:
            logger.debug(
                f&#34;Calling LLM model with these parameters: {logged_params}. Not showing &#39;messages&#39; parameter.&#34;
            )
            return self.client.chat.completions.create(**chat_api_params)

    def _is_reasoning_model(self, model):
        return &#34;o1&#34; in model or &#34;o3&#34; in model

    def _raw_model_response_extractor(self, response):
        &#34;&#34;&#34;
        Extracts the response from the API response. Subclasses should
        override this method to implement their own response extraction.
        &#34;&#34;&#34;
        return response.choices[0].message.to_dict()

    def _get_cached_response(self, cache_key):
        if not self.cache_api_calls:
            return None

        cache_store = getattr(self, &#34;api_cache&#34;, None)
        if cache_store is None:
            return None

        with self._cache_lock:
            return cache_store.get(cache_key)

    @contextmanager
    def _concurrency_slot(self):
        if self._concurrency_semaphore is None:
            yield
            return

        self._concurrency_semaphore.acquire()
        try:
            yield
        finally:
            self._concurrency_semaphore.release()

    def _count_tokens(self, messages: list, model: str):
        &#34;&#34;&#34;
        Count the number of OpenAI tokens in a list of messages using tiktoken.

        Adapted from https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb

        Args:
        messages (list): A list of dictionaries representing the conversation history.
        model (str): The name of the model to use for encoding the string.
        &#34;&#34;&#34;
        try:
            try:
                encoding = tiktoken.encoding_for_model(model)
            except KeyError:
                logger.debug(
                    &#34;Token count: model not found. Using cl100k_base encoding.&#34;
                )
                encoding = tiktoken.get_encoding(&#34;cl100k_base&#34;)

            if (
                model
                in {
                    &#34;gpt-3.5-turbo-0613&#34;,
                    &#34;gpt-3.5-turbo-16k-0613&#34;,
                    &#34;gpt-4-0314&#34;,
                    &#34;gpt-4-32k-0314&#34;,
                    &#34;gpt-4-0613&#34;,
                    &#34;gpt-4-32k-0613&#34;,
                }
                or &#34;o1&#34; in model
                or &#34;o3&#34; in model
            ):  # assuming o1/3 models work the same way
                tokens_per_message = 3
                tokens_per_name = 1
            elif model == &#34;gpt-3.5-turbo-0301&#34;:
                tokens_per_message = (
                    4  # every message follows &lt;|start|&gt;{role/name}\n{content}&lt;|end|&gt;\n
                )
                tokens_per_name = -1  # if there&#39;s a name, the role is omitted
            elif &#34;gpt-3.5-turbo&#34; in model:
                logger.debug(
                    &#34;Token count: gpt-3.5-turbo may update over time. Returning num tokens assuming gpt-3.5-turbo-0613.&#34;
                )
                return self._count_tokens(messages, model=&#34;gpt-3.5-turbo-0613&#34;)
            elif (&#34;gpt-4&#34; in model) or (&#34;ppo&#34; in model):
                logger.debug(
                    &#34;Token count: gpt-4 may update over time. Returning num tokens assuming gpt-4-0613.&#34;
                )
                return self._count_tokens(messages, model=&#34;gpt-4-0613&#34;)
            elif &#34;gpt-5&#34; in model:
                logger.debug(
                    &#34;Token count: no info on GPT-5 tokenizer yet, so we are just reusing GPT-4&#39;s.&#34;
                )
                return self._count_tokens(messages, model=&#34;gpt-4-0613&#34;)
            else:
                raise NotImplementedError(
                    f&#34;&#34;&#34;_count_tokens() is not implemented for model {model}. See https://github.com/openai/openai-python/blob/main/chatml.md for information on how messages are converted to tokens.&#34;&#34;&#34;
                )

            num_tokens = 0
            for message in messages:
                num_tokens += tokens_per_message
                for key, value in message.items():
                    num_tokens += len(encoding.encode(value))
                    if key == &#34;name&#34;:
                        num_tokens += tokens_per_name
            num_tokens += 3  # every reply is primed with &lt;|start|&gt;assistant&lt;|message|&gt;
            return num_tokens

        except Exception as e:
            logger.error(f&#34;Error counting tokens: {e}&#34;)
            return None

    def _save_cache(self):
        &#34;&#34;&#34;
        Saves the API cache to disk. We use pickle to do that because some obj
        are not JSON serializable.
        &#34;&#34;&#34;
        # use pickle to save the cache
        with open(self.cache_file_name, &#34;wb&#34;) as f:
            pickle.dump(self.api_cache, f)

    def _load_cache(self):
        &#34;&#34;&#34;
        Loads the API cache from disk.
        &#34;&#34;&#34;
        if os.path.exists(self.cache_file_name):
            try:
                with open(self.cache_file_name, &#34;rb&#34;) as f:
                    return pickle.load(f)
            except (EOFError, pickle.UnpicklingError) as e:
                logger.warning(f&#34;Cache file exists but could not be loaded: {e}. Starting with empty cache.&#34;)
                return {}
        return {}

    @config_manager.config_defaults(model=&#34;embedding_model&#34;)
    def get_embedding(self, text, model=None):
        &#34;&#34;&#34;
        Gets the embedding of the given text using the specified model.

        Args:
        text (str): The text to embed.
        model (str): The name of the model to use for embedding the text.

        Returns:
        The embedding of the text.
        &#34;&#34;&#34;
        response = self._raw_embedding_model_call(text, model)
        return self._raw_embedding_model_response_extractor(response)

    def _raw_embedding_model_call(self, text, model):
        &#34;&#34;&#34;
        Calls the OpenAI API to get the embedding of the given text. Subclasses should
        override this method to implement their own API calls.
        &#34;&#34;&#34;
        return self.client.embeddings.create(input=[text], model=model)

    def _raw_embedding_model_response_extractor(self, response):
        &#34;&#34;&#34;
        Extracts the embedding from the API response. Subclasses should
        override this method to implement their own response extraction.
        &#34;&#34;&#34;
        return response.data[0].embedding

    def _update_cost_stats(self, response, was_cached):
        &#34;&#34;&#34;
        Updates the cost statistics based on the API response.

        Args:
            response: The response object from the API.
            was_cached (bool): Whether this response came from cache.
        &#34;&#34;&#34;
        with self._cost_stats_lock:
            if was_cached:
                self._cached_calls += 1
            else:
                self._model_calls += 1

            # Extract token usage from response if available
            if hasattr(response, &#34;usage&#34;):
                usage = response.usage
                if hasattr(usage, &#34;prompt_tokens&#34;):
                    self._input_tokens += usage.prompt_tokens
                if hasattr(usage, &#34;completion_tokens&#34;):
                    self._output_tokens += usage.completion_tokens
                if hasattr(usage, &#34;total_tokens&#34;):
                    self._total_tokens += usage.total_tokens

                # Log the latest values in debug mode
                logger.debug(
                    f&#34;Cost stats updated - Input tokens: {usage.prompt_tokens if hasattr(usage, &#39;prompt_tokens&#39;) else 0}, &#34;
                    f&#34;Output tokens: {usage.completion_tokens if hasattr(usage, &#39;completion_tokens&#39;) else 0}, &#34;
                    f&#34;Total tokens: {usage.total_tokens if hasattr(usage, &#39;total_tokens&#39;) else 0}, &#34;
                    f&#34;Cached: {was_cached}&#34;
                )

    def get_cost_stats(self):
        &#34;&#34;&#34;
        Returns the current cost statistics.

        Returns:
            dict: A dictionary containing cost statistics with keys:
                - input_tokens: Number of input/prompt tokens used
                - output_tokens: Number of output/completion tokens used
                - total_tokens: Total number of tokens used
                - model_calls: Number of actual API calls made
                - cached_calls: Number of calls served from cache
        &#34;&#34;&#34;
        with self._cost_stats_lock:
            return {
                &#34;input_tokens&#34;: self._input_tokens,
                &#34;output_tokens&#34;: self._output_tokens,
                &#34;total_tokens&#34;: self._total_tokens,
                &#34;model_calls&#34;: self._model_calls,
                &#34;cached_calls&#34;: self._cached_calls,
            }

    def pretty_print_cost_stats(self):
        &#34;&#34;&#34;
        Pretty prints the cost statistics to the console.
        &#34;&#34;&#34;
        stats = self.get_cost_stats()
        print(&#34;\n&#34; + &#34;=&#34; * 60)
        print(&#34;LLM API COST STATISTICS&#34;)
        print(&#34;=&#34; * 60)
        print(f&#34;Input tokens:         {stats[&#39;input_tokens&#39;]:,}&#34;)
        print(f&#34;Output tokens:        {stats[&#39;output_tokens&#39;]:,}&#34;)
        print(f&#34;Total tokens:         {stats[&#39;total_tokens&#39;]:,}&#34;)
        print(f&#34;Model API calls:      {stats[&#39;model_calls&#39;]:,}&#34;)
        print(f&#34;Cached calls:         {stats[&#39;cached_calls&#39;]:,}&#34;)
        print(f&#34;Total calls:          {stats[&#39;model_calls&#39;] + stats[&#39;cached_calls&#39;]:,}&#34;)
        if stats[&#34;model_calls&#34;] &gt; 0:
            print(
                f&#34;Avg tokens per call:  {stats[&#39;total_tokens&#39;] / stats[&#39;model_calls&#39;]:.1f}&#34;
            )
        print(&#34;=&#34; * 60 + &#34;\n&#34;)

    def reset_cost_stats(self):
        &#34;&#34;&#34;
        Resets the cost statistics. This is the public method that users should call.
        &#34;&#34;&#34;
        self._reset_cost_stats()
        logger.info(&#34;Cost statistics have been reset.&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tinytroupe.clients.azure_client.AzureClient" href="azure_client.html#tinytroupe.clients.azure_client.AzureClient">AzureClient</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tinytroupe.clients.openai_client.OpenAIClient.get_cost_stats"><code class="name flex">
<span>def <span class="ident">get_cost_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current cost statistics.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing cost statistics with keys:
- input_tokens: Number of input/prompt tokens used
- output_tokens: Number of output/completion tokens used
- total_tokens: Total number of tokens used
- model_calls: Number of actual API calls made
- cached_calls: Number of calls served from cache</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cost_stats(self):
    &#34;&#34;&#34;
    Returns the current cost statistics.

    Returns:
        dict: A dictionary containing cost statistics with keys:
            - input_tokens: Number of input/prompt tokens used
            - output_tokens: Number of output/completion tokens used
            - total_tokens: Total number of tokens used
            - model_calls: Number of actual API calls made
            - cached_calls: Number of calls served from cache
    &#34;&#34;&#34;
    with self._cost_stats_lock:
        return {
            &#34;input_tokens&#34;: self._input_tokens,
            &#34;output_tokens&#34;: self._output_tokens,
            &#34;total_tokens&#34;: self._total_tokens,
            &#34;model_calls&#34;: self._model_calls,
            &#34;cached_calls&#34;: self._cached_calls,
        }</code></pre>
</details>
</dd>
<dt id="tinytroupe.clients.openai_client.OpenAIClient.get_embedding"><code class="name flex">
<span>def <span class="ident">get_embedding</span></span>(<span>self, text, model=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the embedding of the given text using the specified model.</p>
<p>Args:
text (str): The text to embed.
model (str): The name of the model to use for embedding the text.</p>
<p>Returns:
The embedding of the text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@config_manager.config_defaults(model=&#34;embedding_model&#34;)
def get_embedding(self, text, model=None):
    &#34;&#34;&#34;
    Gets the embedding of the given text using the specified model.

    Args:
    text (str): The text to embed.
    model (str): The name of the model to use for embedding the text.

    Returns:
    The embedding of the text.
    &#34;&#34;&#34;
    response = self._raw_embedding_model_call(text, model)
    return self._raw_embedding_model_response_extractor(response)</code></pre>
</details>
</dd>
<dt id="tinytroupe.clients.openai_client.OpenAIClient.pretty_print_cost_stats"><code class="name flex">
<span>def <span class="ident">pretty_print_cost_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty prints the cost statistics to the console.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print_cost_stats(self):
    &#34;&#34;&#34;
    Pretty prints the cost statistics to the console.
    &#34;&#34;&#34;
    stats = self.get_cost_stats()
    print(&#34;\n&#34; + &#34;=&#34; * 60)
    print(&#34;LLM API COST STATISTICS&#34;)
    print(&#34;=&#34; * 60)
    print(f&#34;Input tokens:         {stats[&#39;input_tokens&#39;]:,}&#34;)
    print(f&#34;Output tokens:        {stats[&#39;output_tokens&#39;]:,}&#34;)
    print(f&#34;Total tokens:         {stats[&#39;total_tokens&#39;]:,}&#34;)
    print(f&#34;Model API calls:      {stats[&#39;model_calls&#39;]:,}&#34;)
    print(f&#34;Cached calls:         {stats[&#39;cached_calls&#39;]:,}&#34;)
    print(f&#34;Total calls:          {stats[&#39;model_calls&#39;] + stats[&#39;cached_calls&#39;]:,}&#34;)
    if stats[&#34;model_calls&#34;] &gt; 0:
        print(
            f&#34;Avg tokens per call:  {stats[&#39;total_tokens&#39;] / stats[&#39;model_calls&#39;]:.1f}&#34;
        )
    print(&#34;=&#34; * 60 + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="tinytroupe.clients.openai_client.OpenAIClient.reset_cost_stats"><code class="name flex">
<span>def <span class="ident">reset_cost_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the cost statistics. This is the public method that users should call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_cost_stats(self):
    &#34;&#34;&#34;
    Resets the cost statistics. This is the public method that users should call.
    &#34;&#34;&#34;
    self._reset_cost_stats()
    logger.info(&#34;Cost statistics have been reset.&#34;)</code></pre>
</details>
</dd>
<dt id="tinytroupe.clients.openai_client.OpenAIClient.send_message"><code class="name flex">
<span>def <span class="ident">send_message</span></span>(<span>self, current_messages, dedent_messages=True, model=None, temperature=None, max_completion_tokens=None, top_p=None, frequency_penalty=None, presence_penalty=None, stop=None, timeout=None, max_attempts=None, waiting_time=None, exponential_backoff_factor=None, n=1, response_format=None, enable_pydantic_model_return=False, echo=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a message to the OpenAI API and returns the response.</p>
<p>Args:
current_messages (list): A list of dictionaries representing the conversation history.
dedent_messages (bool): Whether to dedent the messages before sending them to the API.
model (str): The ID of the model to use for generating the response.
temperature (float): Controls the "creativity" of the response. Higher values result in more diverse responses.
max_completion_tokens (int): The maximum number of tokens (words or punctuation marks) to generate in the response.
top_p (float): Controls the "quality" of the response. Higher values result in more coherent responses.
frequency_penalty (float): Controls the "repetition" of the response. Higher values result in less repetition.
presence_penalty (float): Controls the "diversity" of the response. Higher values result in more diverse responses.
stop (str): A string that, if encountered in the generated response, will cause the generation to stop.
max_attempts (int): The maximum number of attempts to make before giving up on generating a response.
timeout (int): The maximum number of seconds to wait for a response from the API.
waiting_time (int): The number of seconds to wait between requests.
exponential_backoff_factor (int): The factor by which to increase the waiting time between requests.
n (int): The number of completions to generate.
response_format: The format of the response, if any.
echo (bool): Whether to echo the input message in the response.
enable_pydantic_model_return (bool): Whether to enable Pydantic model return instead of dict when possible.</p>
<p>Returns:
A dictionary representing the generated response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@config_manager.config_defaults(
    model=&#34;model&#34;,
    temperature=&#34;temperature&#34;,
    max_completion_tokens=&#34;max_completion_tokens&#34;,
    frequency_penalty=&#34;frequency_penalty&#34;,
    presence_penalty=&#34;presence_penalty&#34;,
    timeout=&#34;timeout&#34;,
    max_attempts=&#34;max_attempts&#34;,
    waiting_time=&#34;waiting_time&#34;,
    exponential_backoff_factor=&#34;exponential_backoff_factor&#34;,
    response_format=None,
    echo=None,
)
def send_message(
    self,
    current_messages,
    dedent_messages=True,
    model=None,
    temperature=None,
    max_completion_tokens=None,
    top_p=None,
    frequency_penalty=None,
    presence_penalty=None,
    stop=None,
    timeout=None,
    max_attempts=None,
    waiting_time=None,
    exponential_backoff_factor=None,
    n=1,
    response_format=None,
    enable_pydantic_model_return=False,
    echo=False,
):
    &#34;&#34;&#34;
    Sends a message to the OpenAI API and returns the response.

    Args:
    current_messages (list): A list of dictionaries representing the conversation history.
    dedent_messages (bool): Whether to dedent the messages before sending them to the API.
    model (str): The ID of the model to use for generating the response.
    temperature (float): Controls the &#34;creativity&#34; of the response. Higher values result in more diverse responses.
    max_completion_tokens (int): The maximum number of tokens (words or punctuation marks) to generate in the response.
    top_p (float): Controls the &#34;quality&#34; of the response. Higher values result in more coherent responses.
    frequency_penalty (float): Controls the &#34;repetition&#34; of the response. Higher values result in less repetition.
    presence_penalty (float): Controls the &#34;diversity&#34; of the response. Higher values result in more diverse responses.
    stop (str): A string that, if encountered in the generated response, will cause the generation to stop.
    max_attempts (int): The maximum number of attempts to make before giving up on generating a response.
    timeout (int): The maximum number of seconds to wait for a response from the API.
    waiting_time (int): The number of seconds to wait between requests.
    exponential_backoff_factor (int): The factor by which to increase the waiting time between requests.
    n (int): The number of completions to generate.
    response_format: The format of the response, if any.
    echo (bool): Whether to echo the input message in the response.
    enable_pydantic_model_return (bool): Whether to enable Pydantic model return instead of dict when possible.

    Returns:
    A dictionary representing the generated response.
    &#34;&#34;&#34;

    from tinytroupe.clients import (  # avoid circular import
        InvalidRequestError,
        NonTerminalError,
    )

    def aux_exponential_backoff():
        nonlocal waiting_time

        # in case waiting time was initially set to 0
        if waiting_time &lt;= 0:
            waiting_time = 2

        logger.info(
            f&#34;Request failed. Waiting {waiting_time} seconds between requests...&#34;
        )
        time.sleep(waiting_time)

        # exponential backoff
        waiting_time = waiting_time * exponential_backoff_factor

    # setup the OpenAI configurations for this client.
    self._setup_from_config()

    # dedent the messages (field &#39;content&#39; only) if needed (using textwrap)
    if dedent_messages:
        for message in current_messages:
            if &#34;content&#34; in message:
                message[&#34;content&#34;] = utils.dedent(message[&#34;content&#34;])

    # We need to adapt the parameters to the API type, so we create a dictionary with them first
    chat_api_params = {
        &#34;model&#34;: model,
        &#34;messages&#34;: current_messages,
        &#34;temperature&#34;: temperature,
        &#34;max_completion_tokens&#34;: max_completion_tokens,
        &#34;top_p&#34;: top_p,
        &#34;frequency_penalty&#34;: frequency_penalty,
        &#34;presence_penalty&#34;: presence_penalty,
        &#34;stop&#34;: stop,
        &#34;timeout&#34;: timeout,
        &#34;stream&#34;: False,
        &#34;n&#34;: n,
    }

    if response_format is not None:
        chat_api_params[&#34;response_format&#34;] = response_format

    # remove any parameter that is None, so we use the API defaults
    chat_api_params = {k: v for k, v in chat_api_params.items() if v is not None}

    i = 0
    while i &lt; max_attempts:
        try:
            i += 1

            try:
                logger.debug(
                    f&#34;Sending messages to OpenAI API. Token count={self._count_tokens(current_messages, model)}.&#34;
                )
            except NotImplementedError:
                logger.debug(f&#34;Token count not implemented for model {model}.&#34;)

            start_time = time.monotonic()
            logger.debug(
                f&#34;Calling model with client class {self.__class__.__name__}.&#34;
            )

            ###############################################################
            # call the model, either from the cache or from the API
            ###############################################################
            cache_key = str((model, chat_api_params))  # need string to be hashable

            pre_cached_response = self._get_cached_response(cache_key)

            should_wait_before_call = (
                waiting_time &gt; 0 and pre_cached_response is None
            )

            if should_wait_before_call:
                logger.info(
                    f&#34;Waiting {waiting_time} seconds before next API request (to avoid throttling)...&#34;
                )
                time.sleep(waiting_time)

            with self._concurrency_slot():
                response = None
                cached_response = (
                    pre_cached_response
                    if pre_cached_response is not None
                    else self._get_cached_response(cache_key)
                )

                if cached_response is not None:
                    response = cached_response
                else:
                    response = self._raw_model_call(model, chat_api_params)
                    if self.cache_api_calls:
                        with self._cache_lock:
                            existing = (
                                self.api_cache.get(cache_key)
                                if hasattr(self, &#34;api_cache&#34;)
                                else None
                            )
                            if existing is None:
                                self.api_cache[cache_key] = response
                                self._save_cache()
                            else:
                                response = existing

                raw_message = self._raw_model_response_extractor(response)

                # Update cost statistics
                self._update_cost_stats(response, cached_response is not None)

            logger.debug(f&#34;Got response from API: {response}&#34;)
            end_time = time.monotonic()
            logger.debug(
                f&#34;Got response in {end_time - start_time:.2f} seconds after {i} attempts.&#34;
            )

            if enable_pydantic_model_return:
                return utils.to_pydantic_or_sanitized_dict(
                    raw_message,
                    model=response_format,
                )
            else:
                return utils.sanitize_dict(raw_message)

        except InvalidRequestError as e:
            logger.error(f&#34;[{i}] Invalid request error, won&#39;t retry: {e}&#34;)

            # there&#39;s no point in retrying if the request is invalid
            # so we return None right away
            return None

        except openai.BadRequestError as e:
            logger.error(f&#34;[{i}] Invalid request error, won&#39;t retry: {e}&#34;)

            # there&#39;s no point in retrying if the request is invalid
            # so we return None right away
            return None

        except openai.RateLimitError:
            logger.warning(
                f&#34;[{i}] Rate limit error, waiting a bit and trying again.&#34;
            )
            aux_exponential_backoff()

        except NonTerminalError as e:
            logger.error(f&#34;[{i}] Non-terminal error: {e}&#34;)
            aux_exponential_backoff()

        except APITimeoutError as e:
            logger.error(f&#34;[{i}] API Timeout error: {e}&#34;)
            # no exponential timeout backoff here, just retry

        except Exception as e:
            logger.error(f&#34;[{i}] {type(e).__name__} Error: {e}&#34;)
            aux_exponential_backoff()

    logger.error(f&#34;Failed to get response after {max_attempts} attempts.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="tinytroupe.clients.openai_client.OpenAIClient.set_api_cache"><code class="name flex">
<span>def <span class="ident">set_api_cache</span></span>(<span>self, cache_api_calls, cache_file_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables or disables the caching of API calls.</p>
<p>Args:
cache_file_name (str): The name of the file to use for caching API calls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@config_manager.config_defaults(cache_file_name=&#34;cache_file_name&#34;)
def set_api_cache(self, cache_api_calls, cache_file_name=None):
    &#34;&#34;&#34;
    Enables or disables the caching of API calls.

    Args:
    cache_file_name (str): The name of the file to use for caching API calls.
    &#34;&#34;&#34;
    self.cache_api_calls = cache_api_calls
    self.cache_file_name = cache_file_name
    if self.cache_api_calls:
        # load the cache, if any
        self.api_cache = self._load_cache()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tinytroupe.clients" href="index.html">tinytroupe.clients</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tinytroupe.clients.openai_client.OpenAIClient" href="#tinytroupe.clients.openai_client.OpenAIClient">OpenAIClient</a></code></h4>
<ul class="">
<li><code><a title="tinytroupe.clients.openai_client.OpenAIClient.get_cost_stats" href="#tinytroupe.clients.openai_client.OpenAIClient.get_cost_stats">get_cost_stats</a></code></li>
<li><code><a title="tinytroupe.clients.openai_client.OpenAIClient.get_embedding" href="#tinytroupe.clients.openai_client.OpenAIClient.get_embedding">get_embedding</a></code></li>
<li><code><a title="tinytroupe.clients.openai_client.OpenAIClient.pretty_print_cost_stats" href="#tinytroupe.clients.openai_client.OpenAIClient.pretty_print_cost_stats">pretty_print_cost_stats</a></code></li>
<li><code><a title="tinytroupe.clients.openai_client.OpenAIClient.reset_cost_stats" href="#tinytroupe.clients.openai_client.OpenAIClient.reset_cost_stats">reset_cost_stats</a></code></li>
<li><code><a title="tinytroupe.clients.openai_client.OpenAIClient.send_message" href="#tinytroupe.clients.openai_client.OpenAIClient.send_message">send_message</a></code></li>
<li><code><a title="tinytroupe.clients.openai_client.OpenAIClient.set_api_cache" href="#tinytroupe.clients.openai_client.OpenAIClient.set_api_cache">set_api_cache</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>